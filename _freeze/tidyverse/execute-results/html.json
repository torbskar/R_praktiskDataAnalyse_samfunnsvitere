{
  "hash": "67e967e0da51fb29726b731f9f3bb464",
  "result": {
    "engine": "knitr",
    "markdown": "# Datahåndtering med tidyverse\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(haven)\n```\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\nI et tidligere kapittel ble det nevnt at R har ulike \"dialekter\". I denne boken bruker vi **tidyverse** konsekvent, og dette kapittelet går grundigere inn i hvordan man bruker tidyverse til datahåndtering. Datahåndtering er alt man gjør med dataene *før* man analyserer dem: lage nye variable, velge ut variable, filtrere observasjoner, sortere, gruppere og oppsummere.\n\nTidyverse er en samling pakker som deler en felles filosofi og syntaks. Kjernepakken for datahåndtering er `dplyr`, som lastes automatisk når du laster `tidyverse`. Poenget med tidyverse er at koden skal være lesbar og logisk, nesten som å lese setninger.\n\nVi bruker datasettet *abu89* i eksemplene som følger. Dette datasettet inneholder informasjon om lønn, alder, utdanning, kjønn, klasse og sektor for et utvalg arbeidstakere. La oss først se på dataene:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(abu89)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 4,127\nColumns: 9\n$ io_nr    <dbl> 3, 4, 5, 8, 11, 12, 13, 14, 16, 17, 18, 19, 20, 21, 22, 23, 2…\n$ time89   <dbl> 62.00000, NA, 91.32895, 84.23913, 90.42553, 103.28947, 75.000…\n$ ed       <dbl> 0, 1, 3, 5, 3, 1, 1, 7, 3, 9, 0, 9, 1, 3, 9, 3, 0, 3, 1, 3, 3…\n$ age      <dbl> 58, 24, 44, 46, 40, 36, 31, 31, 26, 29, 54, 58, 25, 25, 56, 5…\n$ female   <dbl> 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1…\n$ klasse89 <fct> III Rutinefunksjonærer, VIIa Ufaglærte arbeidere, II Nedre se…\n$ promot   <fct> NEI, JA, JA, NEI, NEI, NEI, NEI, NEI, JA, NEI, JA, JA, NEI, J…\n$ fexp     <dbl> 1.0, 0.3, 1.9, 0.3, 1.0, 1.2, 0.1, 0.4, 0.2, 0.3, 3.5, 3.1, 0…\n$ private  <fct> Public, Private, Private, Public, Private, Public, Public, Pr…\n```\n\n\n:::\n:::\n\n\n\n## Pipe-operatoren: `%>%`\n\nDet viktigste konseptet i tidyverse er \"pipen\" `%>%`. Den betyr rett og slett \"ta dette, og gjør deretter...\". Pipen sender resultatet fra venstre side videre som input til funksjonen på høyre side.\n\nHurtigtasten er **Ctrl + Shift + M** (du kommer til å bruke denne mye!).\n\nUten pipe ville vi skrevet noe slikt:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(abu89)\n```\n:::\n\n\nMed pipe kan vi skrive det slik:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabu89 %>% head()\n```\n:::\n\n\nI dette enkle eksempelet er det ingen stor forskjell. Men pipen blir veldig nyttig når man skal gjøre *flere ting etter hverandre*. Uten pipe ender man opp med enten svært uleselig nøsting av funksjoner eller mange mellomliggende objekter. Med pipe kan man kjede sammen operasjoner slik:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabu89 %>%\n  filtrer noe %>%\n  lag ny variabel %>%\n  oppsummer\n```\n:::\n\n\nDette er pseudokode, men illustrerer poenget: man leser koden fra topp til bunn, steg for steg. Merk at det finnes en nyere pipe i base R: `|>`. Den fungerer omtrent likt for de aller fleste formål, og du vil se begge brukt i kodeeksempler på nettet. I denne boken bruker vi `%>%` konsekvent.\n\n\n## `mutate()` -- lage nye variable\n\nFunksjonen `mutate()` brukes til å lage nye variable eller endre eksisterende. Nye variable legges til som en ny kolonne i datasettet.\n\n### Enkel beregning\nLa oss si vi ønsker å lage en variabel som inneholder alderen i måneder:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabu89 %>%\n  mutate(alder_mnd = age * 12) %>%\n  select(io_nr, age, alder_mnd) %>%\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  io_nr   age alder_mnd\n  <dbl> <dbl>     <dbl>\n1     3    58       696\n2     4    24       288\n3     5    44       528\n4     8    46       552\n5    11    40       480\n6    12    36       432\n```\n\n\n:::\n:::\n\n\nMerk at vi ikke har endret det opprinnelige datasettet. For å lagre endringen må vi legge resultatet tilbake i et objekt:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabu89 <- abu89 %>%\n  mutate(alder_mnd = age * 12)\n```\n:::\n\n\n### Lage aldersgrupper med `case_when()`\nEt svært vanlig behov er å lage kategorier basert på en kontinuerlig variabel. Det gjøres med `case_when()` inni `mutate()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabu89 <- abu89 %>%\n  mutate(aldersgruppe = case_when(\n    age < 30              ~ \"Under 30\",\n    age >= 30 & age < 40  ~ \"30-39\",\n    age >= 40 & age < 50  ~ \"40-49\",\n    age >= 50             ~ \"50+\"\n  ))\n\nabu89 %>%\n  select(age, aldersgruppe) %>%\n  head(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 2\n     age aldersgruppe\n   <dbl> <chr>       \n 1    58 50+         \n 2    24 Under 30    \n 3    44 40-49       \n 4    46 40-49       \n 5    40 40-49       \n 6    36 30-39       \n 7    31 30-39       \n 8    31 30-39       \n 9    26 Under 30    \n10    29 Under 30    \n```\n\n\n:::\n:::\n\n\n`case_when()` går gjennom betingelsene fra topp til bunn og tildeler verdien på høyre side av `~` for den første betingelsen som er oppfylt. Rekkefølgen har altså betydning.\n\n### Lage en binær variabel med `ifelse()`\nFor enklere tilfeller med bare to kategorier kan man bruke `ifelse()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabu89 <- abu89 %>%\n  mutate(hoy_lonn = ifelse(time89 > 150, \"Høy lønn\", \"Lav/middels lønn\"))\n\nabu89 %>%\n  select(time89, hoy_lonn) %>%\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 2\n  time89 hoy_lonn        \n   <dbl> <chr>           \n1   62   Lav/middels lønn\n2   NA   <NA>            \n3   91.3 Lav/middels lønn\n4   84.2 Lav/middels lønn\n5   90.4 Lav/middels lønn\n6  103.  Lav/middels lønn\n```\n\n\n:::\n:::\n\n\n\n## `select()` -- velge variable\n\nFunksjonen `select()` brukes til å velge ut variable (kolonner) du ønsker å beholde -- eller fjerne de du ikke trenger.\n\n### Velge variable\n\n::: {.cell}\n\n```{.r .cell-code}\nabu89 %>%\n  select(io_nr, age, time89, female) %>%\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  io_nr   age time89 female\n  <dbl> <dbl>  <dbl>  <dbl>\n1     3    58   62        1\n2     4    24   NA        0\n3     5    44   91.3      1\n4     8    46   84.2      1\n5    11    40   90.4      0\n6    12    36  103.       0\n```\n\n\n:::\n:::\n\n\n### Fjerne variable\nBruker man minus-tegn foran variabelnavnet fjernes den:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabu89 %>%\n  select(-io_nr, -alder_mnd, -aldersgruppe, -hoy_lonn) %>%\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 8\n  time89    ed   age female klasse89                 promot  fexp private\n   <dbl> <dbl> <dbl>  <dbl> <fct>                    <fct>  <dbl> <fct>  \n1   62       0    58      1 III Rutinefunksjonærer   NEI      1   Public \n2   NA       1    24      0 VIIa Ufaglærte arbeidere JA       0.3 Private\n3   91.3     3    44      1 II Nedre serviceklasse   JA       1.9 Private\n4   84.2     5    46      1 II Nedre serviceklasse   NEI      0.3 Public \n5   90.4     3    40      0 II Nedre serviceklasse   NEI      1   Private\n6  103.      1    36      0 II Nedre serviceklasse   NEI      1.2 Public \n```\n\n\n:::\n:::\n\n\n### Hjelpefunksjoner i `select()`\nDet finnes nyttige hjelpefunksjoner for å velge variable basert på navnemønster:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Velg alle variable som starter med en bestemt tekst\nabu89 %>% select(starts_with(\"time\"))\n\n# Velg alle variable som inneholder en bestemt tekst\nabu89 %>% select(contains(\"89\"))\n\n# Velg alle numeriske variable\nabu89 %>% select(where(is.numeric))\n```\n:::\n\n\nDisse er spesielt nyttige når man jobber med datasett som har mange variable.\n\n\n## `filter()` -- filtrere rader\n\nMens `select()` velger kolonner, velger `filter()` rader basert på betingelser. Her brukes logiske operatorer som `==`, `!=`, `>`, `<`, `>=`, `<=`, `&` (og), `|` (eller).\n\n### Filtrere på én betingelse\n\n::: {.cell}\n\n```{.r .cell-code}\nabu89 %>%\n  filter(age > 50) %>%\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 12\n  io_nr time89    ed   age female klasse89        promot  fexp private alder_mnd\n  <dbl>  <dbl> <dbl> <dbl>  <dbl> <fct>           <fct>  <dbl> <fct>       <dbl>\n1     3   62       0    58      1 III Rutinefunk… NEI      1   Public        696\n2    18   89.9     0    54      1 III Rutinefunk… JA       3.5 Public        648\n3    19   NA       9    58      0 I Øvre service… JA       3.1 Public        696\n4    22   NA       9    56      0 I Øvre service… NEI      0.3 Public        672\n5    23  112.      3    54      0 III Rutinefunk… JA       2   Public        648\n6    38   70       0    65      1 V-VI Faglærte … NEI      0.2 Private       780\n# ℹ 2 more variables: aldersgruppe <chr>, hoy_lonn <chr>\n```\n\n\n:::\n:::\n\n\n### Filtrere på flere betingelser\n\n::: {.cell}\n\n```{.r .cell-code}\nabu89 %>%\n  filter(age > 40, female == 1) %>%\n  select(io_nr, age, female, time89) %>%\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  io_nr   age female time89\n  <dbl> <dbl>  <dbl>  <dbl>\n1     3    58      1   62  \n2     5    44      1   91.3\n3     8    46      1   84.2\n4    18    54      1   89.9\n5    38    65      1   70  \n6    39    65      1   73.9\n```\n\n\n:::\n:::\n\n\nNår man skriver flere betingelser adskilt med komma inni `filter()` tolkes det som \"og\" (`&`). Alternativt kan man bruke `|` for \"eller\":\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabu89 %>%\n  filter(age < 25 | age > 60) %>%\n  select(io_nr, age, time89) %>%\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  io_nr   age time89\n  <dbl> <dbl>  <dbl>\n1     4    24   NA  \n2    25    17   41  \n3    36    21   NA  \n4    38    65   70  \n5    39    65   73.9\n6    42    61  118. \n```\n\n\n:::\n:::\n\n\n### Fjerne manglende verdier\nEn vanlig bruk av `filter()` er å fjerne rader med manglende verdier (NA) på en bestemt variabel:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabu89_komplett <- abu89 %>%\n  filter(!is.na(time89))\n```\n:::\n\n\nHer betyr `!is.na()` \"er *ikke* NA\".\n\n::: {.callout-note}\nMerk forskjellen: `select()` velger *kolonner* (variable), mens `filter()` velger *rader* (observasjoner). Denne distinksjonen er viktig!\n:::\n\n\n## `summarise()` -- oppsummere data\n\nFunksjonen `summarise()` (eller `summarize()`, begge stavemåter fungerer) beregner oppsummerende statistikk og returnerer en ny, liten tabell.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabu89 %>%\n  summarise(\n    snitt_lonn = mean(time89, na.rm = TRUE),\n    sd_lonn    = sd(time89, na.rm = TRUE),\n    snitt_alder = mean(age, na.rm = TRUE),\n    antall     = n()\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 4\n  snitt_lonn sd_lonn snitt_alder antall\n       <dbl>   <dbl>       <dbl>  <int>\n1       90.1    30.3        39.7   4127\n```\n\n\n:::\n:::\n\n\nMerk at `n()` gir antall observasjoner. Argumentet `na.rm = TRUE` sier at manglende verdier skal ignoreres i beregningen. Uten dette argumentet vil resultatet bli NA hvis det finnes noen manglende verdier.\n\n\n## `group_by()` -- grupperte operasjoner\n\n`group_by()` gjør egentlig ingenting synlig i seg selv, men endrer hvordan etterfølgende funksjoner oppfører seg. Når man bruker `group_by()` etterfulgt av `summarise()` beregnes statistikken *per gruppe*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabu89 %>%\n  group_by(klasse89) %>%\n  summarise(\n    snitt_lonn = mean(time89, na.rm = TRUE),\n    antall     = n()\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  klasse89                 snitt_lonn antall\n  <fct>                         <dbl>  <int>\n1 I Øvre serviceklasse          118.     328\n2 II Nedre serviceklasse        104.    1181\n3 III Rutinefunksjonærer         75.5   1248\n4 V-VI Faglærte arbeidere        88.7    648\n5 VIIa Ufaglærte arbeidere       81.4    637\n6 <NA>                           92.1     85\n```\n\n\n:::\n:::\n\n\nMan kan også gruppere etter flere variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabu89 %>%\n  group_by(klasse89, female) %>%\n  summarise(\n    snitt_lonn = mean(time89, na.rm = TRUE),\n    antall     = n()\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 4\n# Groups:   klasse89 [6]\n   klasse89                 female snitt_lonn antall\n   <fct>                     <dbl>      <dbl>  <int>\n 1 I Øvre serviceklasse          0      123.     254\n 2 I Øvre serviceklasse          1      102.      74\n 3 II Nedre serviceklasse        0      113.     626\n 4 II Nedre serviceklasse        1       93.6    555\n 5 III Rutinefunksjonærer        0       90.5    262\n 6 III Rutinefunksjonærer        1       71.6    986\n 7 V-VI Faglærte arbeidere       0       89.4    602\n 8 V-VI Faglærte arbeidere       1       79.3     46\n 9 VIIa Ufaglærte arbeidere      0       88.1    393\n10 VIIa Ufaglærte arbeidere      1       71.1    244\n11 <NA>                          0       96.4     56\n12 <NA>                          1       84.1     29\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip}\nHusk å bruke `ungroup()` etter at du er ferdig med grupperingen, spesielt hvis du skal gjøre flere operasjoner etterpå. Ellers kan grupperingen påvirke senere beregninger på uventede måter.\n:::\n\n\n`group_by()` kan også brukes sammen med `mutate()`. Da legges den nye variabelen til i datasettet, men beregningen gjøres per gruppe. Et typisk eksempel er å beregne gruppegjennomsnittet og legge det til som en variabel:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabu89 %>%\n  group_by(klasse89) %>%\n  mutate(snitt_lonn_klasse = mean(time89, na.rm = TRUE)) %>%\n  ungroup() %>%\n  select(io_nr, klasse89, time89, snitt_lonn_klasse) %>%\n  head(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 4\n   io_nr klasse89                 time89 snitt_lonn_klasse\n   <dbl> <fct>                     <dbl>             <dbl>\n 1     3 III Rutinefunksjonærer     62                75.5\n 2     4 VIIa Ufaglærte arbeidere   NA                81.4\n 3     5 II Nedre serviceklasse     91.3             104. \n 4     8 II Nedre serviceklasse     84.2             104. \n 5    11 II Nedre serviceklasse     90.4             104. \n 6    12 II Nedre serviceklasse    103.              104. \n 7    13 VIIa Ufaglærte arbeidere   75                81.4\n 8    14 I Øvre serviceklasse      110.              118. \n 9    16 V-VI Faglærte arbeidere    79                88.7\n10    17 I Øvre serviceklasse      112.              118. \n```\n\n\n:::\n:::\n\n\n\n## `arrange()` -- sortere data\n\nFunksjonen `arrange()` sorterer datasettet etter en eller flere variable. Som standard sorteres det i stigende rekkefølge.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabu89 %>%\n  select(io_nr, age, time89) %>%\n  arrange(time89) %>%\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  io_nr   age time89\n  <dbl> <dbl>  <dbl>\n1   148    48   25  \n2  4107    17   25  \n3  3316    41   25.9\n4  1685    37   26.3\n5  2126    21   26.8\n6   272    18   27.5\n```\n\n\n:::\n:::\n\n\nFor synkende rekkefølge brukes `desc()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabu89 %>%\n  select(io_nr, age, time89) %>%\n  arrange(desc(time89)) %>%\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  io_nr   age time89\n  <dbl> <dbl>  <dbl>\n1  2557    36   344.\n2  3276    35   325 \n3  1188    63   300 \n4  1997    44   300 \n5  3757    42   300 \n6  3751    52   278.\n```\n\n\n:::\n:::\n\n\n\n## Kombinere funksjoner med pipe\n\nDen virkelige styrken med tidyverse er at man kan kombinere alle disse funksjonene i én sammenhengende arbeidsflyt. Her er et eksempel som gjør flere ting:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabu89 %>%\n  filter(!is.na(time89)) %>%                         # Fjern manglende verdier\n  mutate(ed_aar = as.numeric(as.character(ed))) %>%   # Gjør utdanning numerisk\n  group_by(klasse89) %>%                              # Grupper etter klasse\n  summarise(\n    snitt_lonn = mean(time89, na.rm = TRUE),          # Gjennomsnittslønn\n    snitt_alder = mean(age, na.rm = TRUE),             # Gjennomsnittsalder\n    antall = n()                                       # Antall per gruppe\n  ) %>%\n  arrange(desc(snitt_lonn))                            # Sorter etter lønn\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  klasse89                 snitt_lonn snitt_alder antall\n  <fct>                         <dbl>       <dbl>  <int>\n1 I Øvre serviceklasse          118.         40.8    292\n2 II Nedre serviceklasse        104.         40.7   1044\n3 <NA>                           92.1        36.5     79\n4 V-VI Faglærte arbeidere        88.7        38.5    607\n5 VIIa Ufaglærte arbeidere       81.4        40.1    598\n6 III Rutinefunksjonærer         75.5        38.2   1139\n```\n\n\n:::\n:::\n\n\nDenne koden leses som: \"Ta datasettet abu89, fjern deretter rader med manglende lønn, lag deretter en numerisk utdanningsvariabel, grupper deretter etter klasse, beregn deretter gjennomsnitt per klasse, og sorter til slutt etter lønn.\"\n\nDet er god praksis å legge til kommentarer i koden med `#` slik at du husker hva hvert steg gjør.\n\n\n## `across()` -- samme operasjon på flere variable\n\nNoen ganger ønsker man å gjøre det samme med flere variable samtidig. Funksjonen `across()` brukes inni `mutate()` eller `summarise()` for å anvende en funksjon på flere kolonner.\n\nHer er et eksempel der vi beregner gjennomsnittet av alle numeriske variable per klasse:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabu89 %>%\n  group_by(klasse89) %>%\n  summarise(across(where(is.numeric), ~mean(.x, na.rm = TRUE))) %>%\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 8\n  klasse89                 io_nr time89    ed   age female  fexp alder_mnd\n  <fct>                    <dbl>  <dbl> <dbl> <dbl>  <dbl> <dbl>     <dbl>\n1 I Øvre serviceklasse     3112.  118.  6.23   41.1 0.226  0.990      494.\n2 II Nedre serviceklasse   3095.  104.  4.27   40.9 0.470  1.03       491.\n3 III Rutinefunksjonærer   3139.   75.5 1.67   38.5 0.790  0.798      462.\n4 V-VI Faglærte arbeidere  3205.   88.7 1.73   38.9 0.0710 1.03       467.\n5 VIIa Ufaglærte arbeidere 3044.   81.4 0.948  40.1 0.383  0.977      481.\n6 <NA>                     2388.   92.1 2.42   36.6 0.341  0.826      439.\n```\n\n\n:::\n:::\n\n\nSyntaksen `~mean(.x, na.rm = TRUE)` er en forkortet måte å skrive en funksjon på der `.x` er et plassholdernavn for variabelen. `where(is.numeric)` velger alle numeriske variable. Man kan også angi variabelnavn direkte:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabu89 %>%\n  summarise(across(c(age, time89),\n                   list(snitt = ~mean(.x, na.rm = TRUE),\n                        sd = ~sd(.x, na.rm = TRUE))))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 4\n  age_snitt age_sd time89_snitt time89_sd\n      <dbl>  <dbl>        <dbl>     <dbl>\n1      39.7   12.4         90.1      30.3\n```\n\n\n:::\n:::\n\n\nHer beregnes både gjennomsnitt og standardavvik for variablene age og time89. Resultatnavnene settes automatisk sammen av variabelnavn og funksjonsnavnet angitt i `list()`.\n\n`across()` er svært nyttig for å unngå repetitiv kode, men kan virke litt kryptisk i starten. Det er helt greit å skrive ut variabel for variabel til man er komfortabel med `across()`.\n\n\n## Oppsummering\n\nHer er en oversikt over de viktigste funksjonene i dplyr:\n\n| Funksjon       | Hva den gjør                           |\n|:---------------|:---------------------------------------|\n| `mutate()`     | Lager nye variable / endrer eksisterende |\n| `select()`     | Velger (eller fjerner) kolonner        |\n| `filter()`     | Filtrerer rader basert på betingelser  |\n| `summarise()`  | Beregner oppsummerende statistikk      |\n| `group_by()`   | Grupperer data for etterfølgende operasjoner |\n| `arrange()`    | Sorterer rader                         |\n| `across()`     | Anvender funksjoner på flere kolonner  |\n\nAlle disse kan kombineres med `%>%` for å lage ryddige, lesbare arbeidsflyter.\n\n\n## Oppgaver\n\n::: {#exr-}\nBruk datasettet abu89 og lag en ny variabel som angir om en person er over eller under 40 år. Bruk `mutate()` og `ifelse()`.\n:::\n\n::: {#exr-}\nFiltrer datasettet slik at du bare har personer som jobber i privat sektor, og beregn gjennomsnittslønn og gjennomsnittsalder for dette utvalget med `summarise()`.\n:::\n\n::: {#exr-}\nBruk `group_by()` og `summarise()` til å beregne gjennomsnittlig timelønn for hver klasse, fordelt på kjønn. Sorter resultatet etter synkende lønn med `arrange()`.\n:::\n\n::: {#exr-}\nSkriv en sammenhengende pipe som filtrerer bort manglende verdier på timelønn, grupperer etter aldersgruppe (som du lager med `case_when()`), og beregner gjennomsnitt, standardavvik og antall per gruppe.\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}