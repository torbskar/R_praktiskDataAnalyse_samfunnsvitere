{
  "hash": "90d7598913b949d409ba3bb7066a253d",
  "result": {
    "engine": "knitr",
    "markdown": "# Koble sammen og omforme data\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\nI samfunnsvitenskapelig forskning vil man ofte ha behov for data fra ulike kilder. Kanskje har du et datasett med survey-data om individer og et annet med registerdata om kommunene de bor i. Eller du har data fra to ulike tidspunkter som skal kobles sammen. Da trenger du verktøy for å koble datasett sammen.\n\nI tillegg vil du noen ganger oppleve at dataene er organisert på en måte som ikke passer til det du skal gjøre. Data kan være i \"bredt\" format der hvert tidspunkt har sin egen kolonne, mens du trenger det i \"langt\" format der hvert tidspunkt er en egen rad -- eller omvendt. Da trenger du verktøy for å omforme data.\n\nDette kapittelet handler om begge deler: å koble datasett og å omforme data mellom bredt og langt format.\n\n## Koble datasett med join-funksjoner\n\nFor å illustrere hvordan join-funksjoner fungerer lager vi to små eksempeldatasett. Tenk deg at du har et datasett med karakterer fra et kurs og et annet med bakgrunnsinformasjon om studentene.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkarakterer <- tibble(\n  id = c(1, 2, 3, 4),\n  navn = c(\"Anna\", \"Bjørn\", \"Cecilie\", \"David\"),\n  karakter = c(\"A\", \"B\", \"C\", \"B\")\n)\n\nbakgrunn <- tibble(\n  id = c(1, 2, 3, 5),\n  studieprogram = c(\"Sosiologi\", \"Statsvitenskap\", \"Økonomi\", \"Sosiologi\"),\n  kjonn = c(\"K\", \"M\", \"K\", \"M\")\n)\n```\n:::\n\n\nLegg merke til at de to datasettene ikke har helt de samme id-verdiene. Student 4 (David) finnes bare i karakterdatasettet, mens student 5 finnes bare i bakgrunnsdatasettet. Dette er helt vanlig i praksis og det er nettopp derfor det er viktig å forstå de ulike typene joins.\n\nLa oss se på de to datasettene:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkarakterer\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 3\n     id navn    karakter\n  <dbl> <chr>   <chr>   \n1     1 Anna    A       \n2     2 Bjørn   B       \n3     3 Cecilie C       \n4     4 David   B       \n```\n\n\n:::\n\n```{.r .cell-code}\nbakgrunn\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 3\n     id studieprogram  kjonn\n  <dbl> <chr>          <chr>\n1     1 Sosiologi      K    \n2     2 Statsvitenskap M    \n3     3 Økonomi        K    \n4     5 Sosiologi      M    \n```\n\n\n:::\n:::\n\n\n### left_join: Behold alt fra venstre datasett\n\nDen klart vanligste join-funksjonen er `left_join()`. Den beholder alle radene fra det første (venstre) datasettet og legger til informasjon fra det andre datasettet der det finnes en match.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_join(karakterer, bakgrunn, by = \"id\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 5\n     id navn    karakter studieprogram  kjonn\n  <dbl> <chr>   <chr>    <chr>          <chr>\n1     1 Anna    A        Sosiologi      K    \n2     2 Bjørn   B        Statsvitenskap M    \n3     3 Cecilie C        Økonomi        K    \n4     4 David   B        <NA>           <NA> \n```\n\n\n:::\n:::\n\n\nHer ser vi at alle fire studentene fra `karakterer` er med. Anna, Bjørn og Cecilie har fått påkoblet informasjon om studieprogram og kjønn. Men David (id = 4) finnes ikke i `bakgrunn`, så han får `NA` på de nye variablene. Student 5 fra `bakgrunn` er ikke med fordi vedkommende ikke fantes i `karakterer`.\n\nDette er den vanligste situasjonen: du har et hoveddatasett og vil legge til tilleggsinformasjon fra en annen kilde.\n\n### right_join: Behold alt fra høyre datasett\n\n`right_join()` gjør det motsatte: beholder alt fra det andre (høyre) datasettet.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nright_join(karakterer, bakgrunn, by = \"id\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 5\n     id navn    karakter studieprogram  kjonn\n  <dbl> <chr>   <chr>    <chr>          <chr>\n1     1 Anna    A        Sosiologi      K    \n2     2 Bjørn   B        Statsvitenskap M    \n3     3 Cecilie C        Økonomi        K    \n4     5 <NA>    <NA>     Sosiologi      M    \n```\n\n\n:::\n:::\n\n\nNå er student 5 med (fra `bakgrunn`), men David (id = 4) er borte. I praksis brukes `right_join()` sjelden fordi man like gjerne kan bytte rekkefølgen på datasettene og bruke `left_join()`.\n\n### inner_join: Bare rader som finnes i begge\n\n`inner_join()` beholder bare radene som har en match i begge datasettene.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninner_join(karakterer, bakgrunn, by = \"id\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 5\n     id navn    karakter studieprogram  kjonn\n  <dbl> <chr>   <chr>    <chr>          <chr>\n1     1 Anna    A        Sosiologi      K    \n2     2 Bjørn   B        Statsvitenskap M    \n3     3 Cecilie C        Økonomi        K    \n```\n\n\n:::\n:::\n\n\nHer er bare id 1, 2 og 3 med -- altså de som finnes i begge datasett. Både David (id = 4) og student 5 er borte. Dette kan være nyttig når du bare vil ha komplette observasjoner, men vær oppmerksom på at du kan miste data uten å være klar over det.\n\n### full_join: Behold alt fra begge datasett\n\n`full_join()` beholder alle rader fra begge datasettene.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfull_join(karakterer, bakgrunn, by = \"id\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 5\n     id navn    karakter studieprogram  kjonn\n  <dbl> <chr>   <chr>    <chr>          <chr>\n1     1 Anna    A        Sosiologi      K    \n2     2 Bjørn   B        Statsvitenskap M    \n3     3 Cecilie C        Økonomi        K    \n4     4 David   B        <NA>           <NA> \n5     5 <NA>    <NA>     Sosiologi      M    \n```\n\n\n:::\n:::\n\n\nNå er alle med. David får `NA` på studieprogram og kjønn, og student 5 får `NA` på navn og karakter. Dette gir deg all tilgjengelig informasjon, men du må håndtere de manglende verdiene etterpå.\n\n\n### Spesifisere koblingsnøkkel med by-argumentet\n\nI eksemplene ovenfor hadde begge datasettene en variabel som het `id`, og vi koblet på den. Men hva om variablene heter forskjellige ting i de to datasettene? Da må du spesifisere dette eksplisitt.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkarakterer2 <- tibble(\n  student_id = c(1, 2, 3, 4),\n  navn = c(\"Anna\", \"Bjørn\", \"Cecilie\", \"David\"),\n  karakter = c(\"A\", \"B\", \"C\", \"B\")\n)\n\nbakgrunn2 <- tibble(\n  id_nr = c(1, 2, 3, 5),\n  studieprogram = c(\"Sosiologi\", \"Statsvitenskap\", \"Økonomi\", \"Sosiologi\")\n)\n\nleft_join(karakterer2, bakgrunn2, by = c(\"student_id\" = \"id_nr\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 4\n  student_id navn    karakter studieprogram \n       <dbl> <chr>   <chr>    <chr>         \n1          1 Anna    A        Sosiologi     \n2          2 Bjørn   B        Statsvitenskap\n3          3 Cecilie C        Økonomi       \n4          4 David   B        <NA>          \n```\n\n\n:::\n:::\n\n\nHer forteller vi R at `student_id` i det første datasettet tilsvarer `id_nr` i det andre.\n\nDu kan også koble på flere variable samtidig. For eksempel hvis du har paneldata med både person-id og år:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurvey <- tibble(\n  id = c(1, 1, 2, 2),\n  aar = c(2020, 2023, 2020, 2023),\n  tilfredshet = c(7, 8, 5, 6)\n)\n\nregister <- tibble(\n  id = c(1, 1, 2, 2),\n  aar = c(2020, 2023, 2020, 2023),\n  inntekt = c(450000, 510000, 380000, 420000)\n)\n\nleft_join(survey, register, by = c(\"id\", \"aar\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 4\n     id   aar tilfredshet inntekt\n  <dbl> <dbl>       <dbl>   <dbl>\n1     1  2020           7  450000\n2     1  2023           8  510000\n3     2  2020           5  380000\n4     2  2023           6  420000\n```\n\n\n:::\n:::\n\n\n\n### Hva kan gå galt?\n\nDet vanligste problemet er at koblingen gir flere rader enn forventet. Det skjer når det er duplikater i koblingsnøklene. Hvis en id forekommer flere ganger i det ene datasettet, får du en rad for hver kombinasjon. Sjekk derfor alltid antall rader før og etter en join for å forsikre deg om at resultatet er som forventet:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresultat <- left_join(karakterer, bakgrunn, by = \"id\")\nnrow(karakterer)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nnrow(resultat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\nHvis `nrow(resultat)` er større enn `nrow(karakterer)` etter en `left_join()`, så har du sannsynligvis duplikater i koblingsnøklene og bør undersøke dette nærmere.\n\n\n## Omforme data: bredt og langt format\n\nI samfunnsvitenskap jobber vi ofte med paneldata -- altså data der vi har målinger på samme enhet over tid. Slike data kan organiseres på to måter.\n\nI **bredt format** har hver enhet en rad, og hvert tidspunkt har sin egen kolonne:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbred <- tibble(\n  kommune = c(\"Oslo\", \"Bergen\", \"Trondheim\"),\n  arbeidsledighet_2020 = c(4.2, 3.8, 3.5),\n  arbeidsledighet_2021 = c(5.1, 4.5, 4.0),\n  arbeidsledighet_2022 = c(3.9, 3.6, 3.2)\n)\nbred\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 4\n  kommune   arbeidsledighet_2020 arbeidsledighet_2021 arbeidsledighet_2022\n  <chr>                    <dbl>                <dbl>                <dbl>\n1 Oslo                       4.2                  5.1                  3.9\n2 Bergen                     3.8                  4.5                  3.6\n3 Trondheim                  3.5                  4                    3.2\n```\n\n\n:::\n:::\n\n\nI **langt format** har hver måling sin egen rad:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlang <- tibble(\n  kommune = rep(c(\"Oslo\", \"Bergen\", \"Trondheim\"), each = 3),\n  aar = rep(c(2020, 2021, 2022), 3),\n  arbeidsledighet = c(4.2, 5.1, 3.9, 3.8, 4.5, 3.6, 3.5, 4.0, 3.2)\n)\nlang\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9 x 3\n  kommune     aar arbeidsledighet\n  <chr>     <dbl>           <dbl>\n1 Oslo       2020             4.2\n2 Oslo       2021             5.1\n3 Oslo       2022             3.9\n4 Bergen     2020             3.8\n5 Bergen     2021             4.5\n6 Bergen     2022             3.6\n7 Trondheim  2020             3.5\n8 Trondheim  2021             4  \n9 Trondheim  2022             3.2\n```\n\n\n:::\n:::\n\n\nBegge formatene inneholder nøyaktig samme informasjon. Men til analyser og plotting i R vil du som oftest trenge data i langt format. Data fra SSB og andre kilder kommer imidlertid ofte i bredt format. Heldigvis er det enkelt å omforme mellom de to formatene.\n\n\n### Fra bredt til langt med pivot_longer()\n\n`pivot_longer()` gjør data lengre ved å samle flere kolonner til en.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbred %>%\n  pivot_longer(\n    cols = starts_with(\"arbeidsledighet\"),\n    names_to = \"aar\",\n    values_to = \"arbeidsledighet\",\n    names_prefix = \"arbeidsledighet_\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9 x 3\n  kommune   aar   arbeidsledighet\n  <chr>     <chr>           <dbl>\n1 Oslo      2020              4.2\n2 Oslo      2021              5.1\n3 Oslo      2022              3.9\n4 Bergen    2020              3.8\n5 Bergen    2021              4.5\n6 Bergen    2022              3.6\n7 Trondheim 2020              3.5\n8 Trondheim 2021              4  \n9 Trondheim 2022              3.2\n```\n\n\n:::\n:::\n\n\nHer angir vi:\n\n- `cols`: hvilke kolonner som skal omformes (her: alle som starter med \"arbeidsledighet\")\n- `names_to`: hva den nye variabelen med kolonnenavnene skal hete\n- `values_to`: hva den nye variabelen med verdiene skal hete\n- `names_prefix`: en tekst som skal fjernes fra kolonnenavnene (slik at vi får \"2020\" i stedet for \"arbeidsledighet_2020\")\n\nMerk at `aar` her blir en tekstvariabel. Hvis du trenger den som numerisk kan du legge til `names_transform = list(aar = as.numeric)` eller gjøre det i et eget steg etterpå.\n\n\n### Fra langt til bredt med pivot_wider()\n\n`pivot_wider()` gjør det motsatte: sprer rader utover i kolonner.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlang %>%\n  pivot_wider(\n    names_from = aar,\n    values_from = arbeidsledighet,\n    names_prefix = \"arbeidsledighet_\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 4\n  kommune   arbeidsledighet_2020 arbeidsledighet_2021 arbeidsledighet_2022\n  <chr>                    <dbl>                <dbl>                <dbl>\n1 Oslo                       4.2                  5.1                  3.9\n2 Bergen                     3.8                  4.5                  3.6\n3 Trondheim                  3.5                  4                    3.2\n```\n\n\n:::\n:::\n\n\nHer angir vi:\n\n- `names_from`: hvilken variabel som skal gi de nye kolonnenavnene\n- `values_from`: hvilken variabel verdiene skal hentes fra\n- `names_prefix`: en tekst som legges foran de nye kolonnenavnene\n\n### Når trenger du hva?\n\nNoen tommelfingerregler:\n\n- **Langt format** trengs for de fleste analyser i R, inkludert ggplot, regresjonsmodeller og gruppert deskriptiv statistikk. Hvis du skal lage et plott med `ggplot()` der du vil vise utvikling over tid, må dataene være i langt format.\n- **Bredt format** er nyttig for å presentere data i tabeller, og noen spesifikke analyser krever bredt format. Data fra SSB og en del andre kilder leveres typisk i bredt format.\n\nI praksis er det vanligst at du må gjøre om fra bredt til langt format, altså bruke `pivot_longer()`. Men det er greit å vite om begge deler.\n\nDisse funksjonene kan virke litt forvirrende i starten, men blir raskt naturlige når man har brukt dem noen ganger. Det beste tipset er rett og slett å prøve selv på egne data.\n",
    "supporting": [
      "koble_omforme_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}