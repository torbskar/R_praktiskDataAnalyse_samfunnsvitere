{
  "hash": "73996f391c65dbf57db6c17aa7d700b1",
  "result": {
    "engine": "knitr",
    "markdown": "# Haandtering av missing-verdier\n\n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(haven)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n\n\nI nesten alle datasett fra sporreskjemaundersokelser vil det vaere observasjoner der vi mangler informasjon paa noen variable. Noen har ikke svart paa alle sporsmaal, noen har hoppet over deler av skjemaet, og noen ganger er det feil i registreringen. Slike manglende verdier -- eller *missing values* -- er noe du maa forholde deg til i praksis. R representerer manglende verdier med den spesielle verdien `NA` (Not Available), og det er viktig aa forstaa hvordan dette fungerer for aa unngaa feil i analysene.\n\n\n## Hva er NA?\n\n`NA` er Rs maate aa si \"vi vet ikke\". Det er ikke det samme som null eller en tom tekststreng. Det betyr rett og slett at verdien mangler. Du kan tenke paa det som et tomt felt i et regneark -- det er ikke fylt ut, og vi vet ikke hva svaret ville vaert.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(3, 7, NA, 12, NA, 5)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  3  7 NA 12 NA  5\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nLegg merke til at `NA` ikke har anforsselstegn rundt seg. Det er fordi `NA` er en spesiell verdi i R, ikke en tekststreng.\n\n\n## Sjekke for missing-verdier\n\nFor aa finne ut hvilke verdier som er `NA` bruker vi funksjonen `is.na()`. Den returnerer `TRUE` for hver verdi som er `NA` og `FALSE` for resten.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.na(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE  TRUE FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nMerk at du *ikke* kan bruke vanlig likhetstegn for aa sjekke om noe er `NA`. Uttrykket `x == NA` gir nemlig `NA` tilbake -- ikke `TRUE` eller `FALSE` som du kanskje forventer. Det er fordi R tenker at \"vi vet ikke om en ukjent verdi er lik en annen ukjent verdi\". Bruk alltid `is.na()`.\n\nFor et helt datasett kan vi bruke `complete.cases()` for aa finne radene som ikke har noen manglende verdier overhodet:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(complete.cases(abu89))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3680\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nDette forteller oss hvor mange rader i datasettet som har gyldige verdier paa *alle* variable.\n\n\n## Oppsummere missing i datasettet\n\nDet er lurt aa skaffe seg en oversikt over hvor mye missing det er i datasettet for man begynner aa analysere. En rask maate er aa kombinere `colSums()` og `is.na()`:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolSums(is.na(abu89))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   io_nr   time89       ed      age   female klasse89   promot     fexp \n       0      368        0        0        0       85        0        0 \n private \n       0 \n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nDette gir antall `NA` per variabel. Hvis det er mange variable kan det vaere nyttig aa sortere resultatet:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsort(colSums(is.na(abu89)), decreasing = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  time89 klasse89    io_nr       ed      age   female   promot     fexp \n     368       85        0        0        0        0        0        0 \n private \n       0 \n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nFor en visuell oversikt kan du bruke pakken `naniar`:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(naniar)\nvis_miss(abu89)\n```\n:::\n\n\n\n\n\n\n\n\nDenne lager et plott der du ser monstre i missing-verdiene. Det kan for eksempel avslore om det er bestemte variable som har mye missing, eller om det er grupper av observasjoner som mangler paa mange variable samtidig.\n\n\n## Funksjoner og NA: argumentet na.rm\n\nMange funksjoner i R gir `NA` som resultat hvis det er missing-verdier i dataene. Det er egentlig fornuftig: R sier at \"resultatet er ukjent fordi noen av verdiene er ukjente\". Men i praksis vil man som oftest beregne resultatet basert paa de verdiene man faktisk har.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(3, 7, NA, 12, 5)\nmean(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nFor aa faa gjennomsnittet av de verdiene som finnes, bruker vi argumentet `na.rm = TRUE` (som staar for \"NA remove\"):\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(x, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6.75\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nDette gjelder for en rekke funksjoner som `sum()`, `sd()`, `median()`, `min()`, `max()` og andre. Det er et veldig vanlig argument som du kommer til aa bruke ofte.\n\n\n## Filtrere ut missing\n\nNaar du jobber med datasett i tidyverse kan du filtrere bort rader med missing paa bestemte variable. Det gjor du med `filter()` og `is.na()`:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabu89 %>%\n  filter(!is.na(time89)) %>%\n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3759\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nHer beholder vi bare radene der `time89` *ikke* er `NA`. Utropstegnet `!` betyr \"ikke\".\n\nHvis du vil fjerne alle rader som har `NA` paa en eller flere bestemte variable kan du bruke `drop_na()` fra tidyr:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabu89 %>%\n  drop_na(time89, ed) %>%\n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3759\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nUten argumenter fjerner `drop_na()` alle rader med missing paa *noen som helst* variabel. Det kan vaere ganske drastisk, saa det er som regel lurt aa spesifisere hvilke variable du vil fjerne missing paa.\n\n\n## Omkode verdier til NA\n\nI en del datasett er missing-verdier kodet som bestemte tall i stedet for ekte `NA`. For eksempel kan -9, 99 eller 999 bety \"ikke svart\" eller \"vet ikke\". Slike verdier maa du kode om til `NA` selv.\n\nMed `mutate()` og `na_if()` er dette enkelt:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatasett <- datasett %>%\n  mutate(variabel = na_if(variabel, -9))\n```\n:::\n\n\n\n\n\n\n\n\nDette gjor at alle verdier som er lik -9 paa variabelen blir til `NA`. Du kan ogsaa bruke `case_when()` for mer avansert omkoding der flere verdier skal bli `NA`:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatasett <- datasett %>%\n  mutate(variabel = case_when(\n    variabel %in% c(-9, -8, 999) ~ NA_real_,\n    TRUE ~ variabel\n  ))\n```\n:::\n\n\n\n\n\n\n\n\n\n## Erstatte NA med verdier\n\nNoen ganger vil du erstatte `NA` med en bestemt verdi. For eksempel kan det vaere fornuftig aa anta at manglende verdier paa en variabel for antall barn betyr at personen ikke har barn, altsa null.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- c(2, NA, 1, NA, 3)\nreplace_na(y, 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 0 1 0 3\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nI en pipe med `mutate()`:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatasett <- datasett %>%\n  mutate(ant_barn = replace_na(ant_barn, 0))\n```\n:::\n\n\n\n\n\n\n\n\nFunksjonen `coalesce()` er nyttig hvis du har flere variable og vil bruke den forste som ikke er `NA`:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- c(NA, 2, NA, 4)\nb <- c(10, NA, 30, NA)\ncoalesce(a, b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10  2 30  4\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nDenne funksjonen velger den forste ikke-manglende verdien fra venstre til hoyre. Det kan vaere nyttig naar du har informasjon fra flere kilder og vil fylle inn der det mangler.\n\n\n## Missing i regresjonsanalyser\n\nNaar du kjorer en regresjonsmodell med `lm()` i R, saa haandterer funksjonen missing automatisk ved aa fjerne alle observasjoner som har `NA` paa noen av variablene i modellen. Dette kalles *listwise deletion* (eller *complete case analysis*).\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod <- lm(time89 ~ ed + age, data = abu89)\nnobs(mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3759\n```\n\n\n:::\n\n```{.r .cell-code}\nnrow(abu89)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4127\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nLegg merke til at antall observasjoner i modellen (`nobs()`) kan vaere lavere enn antall rader i datasettet. Det er fordi rader med `NA` paa noen av variablene i modellen er fjernet. Det er viktig aa vaere oppmerksom paa dette, spesielt naar du sammenligner modeller med ulike variable. Hvis en variabel har mye missing, kan det endre utvalget betraktelig fra en modell til en annen.\n\nEt godt tips er aa lage et analysedatasett der du fjerner missing paa de relevante variablene forst, slik at alle modeller estimeres paa det samme utvalget:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabu89_analyse <- abu89 %>%\n  drop_na(time89, ed, age)\n\nmod1 <- lm(time89 ~ ed, data = abu89_analyse)\nmod2 <- lm(time89 ~ ed + age, data = abu89_analyse)\n\nnobs(mod1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3759\n```\n\n\n:::\n\n```{.r .cell-code}\nnobs(mod2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3759\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nNaa bruker begge modellene noyaktig samme utvalg, og eventuelle forskjeller skyldes modellspesifikasjonen og ikke at ulike observasjoner er med.\n\n\n## Multippel imputering\n\nListwise deletion er den enkleste tilnaermingen, men den har en ulempe: du mister data. Hvis mange observasjoner har missing paa minst en variabel, kan utvalget bli vesentlig mindre. I tillegg kan resultatene bli skjeve hvis dataene ikke mangler helt tilfeldig.\n\nEn mer avansert tilnaerming er *multippel imputering*, der man estimerer hva de manglende verdiene sannsynligvis ville vaert basert paa den informasjonen man faktisk har. Pakken `mice` i R er det mest brukte verktoeyet for dette. Vi gaar ikke naermere inn paa dette her, men det er greit aa vite at det finnes. Hvis du har mye missing i dataene dine og det er viktig for resultatene, bor du sette deg inn i dette temaet.\n\n\n## Vanlige fallgruver og tips\n\nHer er noen praktiske rad for aa haandtere missing:\n\n- **Sjekk alltid for missing for du begynner aa analysere.** Bruk `summary()` eller `colSums(is.na())` for aa faa en oversikt. Missing-verdier som du ikke er klar over kan gi misvisende resultater.\n- **Bruk `na.rm = TRUE` bevisst.** Det er lett aa bare legge til `na.rm = TRUE` overalt, men tenk igjennom *hvorfor* det er missing. Hvis mange verdier mangler, bor du undersoke dette naermere for du fjerner dem.\n- **Ikke bruk `x == NA`.** Bruk alltid `is.na(x)`. Dette er en av de vanligste nybegynnerfeilene i R.\n- **Pass paa at missing betyr det du tror.** I noen datasett er missing-verdier kodet som -9, 999 eller lignende. Sjekk dokumentasjonen for datasettet og kod om til `NA` der det trengs.\n- **Vaer forsiktig med `drop_na()` uten argumenter.** Uten argumenter fjerner den alle rader med missing paa *hvilken som helst* variabel, noe som kan gi et veldig lite datasett.\n- **Lag et analysedatasett.** Naar du kjorer regresjoner, lag et eget datasett der du har fjernet missing paa de relevante variablene, slik at alle modeller bruker samme utvalg.\n",
    "supporting": [
      "missing_verdier_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}